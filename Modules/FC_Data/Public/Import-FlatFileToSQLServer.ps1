function Import-FlatFileToSQLServer {
<#
    .Synopsis
      Loads data from TXT files generated by Trauma1 into sql tables by creating a generic STAGE table with varchar(max) column data types, and then loading the flat file contents into it.  
    .DESCRIPTION
      A slightly longer description,
    .PARAMETER inputDir
        The directory to pull files from, or the path to a single file to import. 
    .PARAMETER extensionsToInclude
        An array of file types to import. 

        IE: @(".TXT",".CSV")
    .PARAMETER destServerName
        The server name that this will execute against. 
    .PARAMETER destDatabase
        The database name that this will execute against. You need to have access to create and insert data in this database. 

    .PARAMETER schemaName
        The schema name the new tables will have. If the this schema name does not exist, it will create a new one. 
    .PARAMETER executeScripts
        When this switch is activated, the create schema and create table SQL scripts will be executed against the target server/database

    .PARAMETER loadData
         When this switch is activated, the data from the flat files are loaded into tables that match the file name. 
      
    .PARAMETER delimiter
        The character that is deliminating columns in the flat file. Defaults to a comma ","

    .PARAMETER tempDir
        The temp directory to use to store the sql files that are generated. defaults to $env:TEMP
#>
  [CmdletBinding(SupportsShouldProcess = $true)]
  param([Parameter(Position = 0)][ValidateSet("Debug","Info","Warning","Error","Disable")] [string]$logLevel = "Info"
    ,[switch]$winEventLog
    ,[string]$inputDir = $null
    ,[string[]]$extensionsToInclude = @()
    ,[string]$tempDir = $env:TEMP
    ,[string]$destServerName = $null
    ,[string]$destDatabase = $null
    ,[string]$schemaName = $null
    ,[switch]$executeScripts
    ,[switch]$loadData
    ,[string]$delimiter = ",")

  Import-Module FC_Log,DataAccess -Force -DisableNameChecking
  if ([string]::IsNullOrEmpty($logLevel)) { $logLevel = "Info" }
  Set-LogLevel $logLevel
  Set-logTargetWinEvent $winEventLog

  Write-Log "Begining to load data from files with an extension of: ($extensionsToInclude) 
    From the directory: $inputDir"
  Write-Log ""

  if (!(Test-Path $inputDir)) {
    Write-Log "Error finding the path: $inputDir" Error -ErrorAction Stop
  }
  if ((Get-ChildItem $inputDir) -is [System.IO.FileInfo]) {
    $files = Get-ChildItem -Path $inputDir | Where-Object Extension -In $extensionsToInclude
  }
  else {
    $files = Get-ChildItem -Path $inputDir | Where-Object Extension -In $extensionsToInclude
  }

  if ($files -eq $null) {
    Write-Log "Could not find any files with an extension of: $extensionsToInclude at the path: $inputDir. Aborting" Error -ErrorAction Stop
  }
  $loadDate = "$([DateTime]::Now.Year).$([DateTime]::Now.Month).$([DateTime]::Now.Day) "

  $SQLCreateTableStatements = @()

  $sqlCreateSchema = "USE [$destDatabase]
    Go

    IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = '$schemaName')
        exec('CREATE SCHEMA [$schemaName];')
            "
  $createSchemaSQLFile = "$tempDir\Trauma1CreateSchema_$schemaName.sql"
  if (Test-Path $createSchemaSQLFile) {
    Remove-Item $createSchemaSQLFile
  }
  $sqlCreateSchema | Add-Content $createSchemaSQLFile

  if ($executeScripts) {
    Invoke-Sqlcmd -ServerInstance $destServerName -Database $destDatabase -Query $sqlCreateSchema -ErrorAction Stop
  }

  $objStore = @()

  foreach ($file in $files) {
    try {
      $inputFilePath = $file.FullName

      $myObj = New-Object psobject
      $myObj | Add-Member -MemberType NoteProperty -Name FilePath -Value $inputFilePath
      $myObj | Add-Member -MemberType NoteProperty -Name ErrorExists -Value 0
      $myObj | Add-Member -MemberType NoteProperty -Name sqlCommand -Value ""
      $myObj | Add-Member -MemberType NoteProperty -Name ErrorValue -Value ""

      Write-Log "Loading the file: $inputFilePath" Debug
      $tableName = "Stage_$($file.Name)"
      $FQTableName = "[$schemaName].[$tableName]"
      $data = Import-Csv $inputFilePath -Delimiter $delimiter
      $dataAsDataTable = $data | Out-DataTable
      $colNames = (Get-Content $inputFilePath | Select-Object -First 1).Split($delimiter)
      $SQLCreateTable = "USE [$destDatabase]
    Go
    "

      $SQLCreateTable += "
    IF OBJECT_ID('[$destDatabase].$FQTableName') is not null
        Drop Table $FQTableName;

    "


      $SQLCreateTable += "
    Create table $FQTableName (
        "
      $firstPass = 1
      foreach ($col in $colNames) {
        if ($firstPass -eq 1) {
          $SQLCreateTable = $SQLCreateTable + "[$col] varchar(max) null"
          $firstPass = 0
        }
        else {
          $SQLCreateTable = $SQLCreateTable + ",[$col] varchar(max) null"
        }
      }
      $SQLCreateTable = $SQLCreateTable + "
            );

        "
      $myObj.sqlCommand = $SQLCreateTable

      $createTableSQLFile = "$tempDir\Trauma1CreateTable_$tableName.sql"
      if (Test-Path $createTableSQLFile) {
        Remove-Item $createTableSQLFile
      }
      $SQLCreateTable | Add-Content $createTableSQLFile

      if ($executeScripts) {
        Write-Log "Executing create table script for $FQTableName"
        Invoke-Sqlcmd -ServerInstance $destServerName -Database $destDatabase -Query $SQLCreateTable -ErrorAction Stop
      }

      if ($loadData) {
        Write-Log "Loading data into $FQTableName" -tabLevel 1
        Write-DataTable -ServerInstance $destServerName -Database $destDatabase -TableName $FQTableName -data $dataAsDataTable
      }
    }
    catch {
      $myObj.ErrorExists = 1
      $myObj.ErrorValue = $_
    }

    $objStore += $myObj

  }


  Write-Log "Completed reading files."

  $errorCount = ($objStore | Where-Object ErrorExists -EQ 1).count

  if ($errorCount -ne 0) {
    Write-Log "There were $errorCount files that did not load" Warning
    foreach ($obj in $objStore | Where-Object ErrorExists -EQ 1) {
      Write-Log "$($obj.FilePath)" -tabLevel 1
      Write-Log "$($obj.ErrorValue)" -tabLevel 2
    }
  }
} Export-ModuleMember -Function Import-FlatFileToSQLServer